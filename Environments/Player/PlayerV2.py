import gymnasium as gym
import pygame
from gymnasium import spaces
import numpy as np
from stable_baselines3 import DQN

import seaborn as sns
import matplotlib.pyplot as plt
import sympy
from time import time as gettime


class Player(gym.Env):
    """
    Plays the levels generated by the Generator to validate them
    """

    def __init__(self, size=5, preset_level=None, render=False):
        self.size = size
        self.render_mode = render
        self.preset_level = preset_level
        self.prime_percent = 0.3
        self.prime_range = self.max = 5

        self.observation_space = spaces.Dict({
            "board": spaces.Box(0, 100, shape=(self.size, self.size), dtype=int),
            "player_pos": spaces.Box(0, self.size, shape=(2,), dtype=int),
            "current_number": spaces.Discrete(100),
            "lives": spaces.Box(0, 10, shape=(1,), dtype=int),
            "remaining_number_of_primes": spaces.Box(0, 100, shape=(1,), dtype=int),
            "active_primes": spaces.Box(0, 100, shape=(int(self.size * self.size * self.prime_percent),), dtype=int)
        })

        self.action_space = spaces.Discrete(5)

    def _get_obs(self):
        return {
            "board": self.board,
            "player_pos": self.player_pos,
            "current_number": self.current_number,
            "remaining_number_of_primes": self.remaining_number_of_primes,
            "lives": self.remaining_lives,
            "active_primes": self.active_primes
        }

    def reset(
            self,
            seed=None,
            options=None,
    ):
        self.board, self.active_primes = self.gen_board()
        self.player_pos = np.array([0, 0])  # X, Y
        self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]
        self.remaining_number_of_primes = [int(self.size * self.size * self.prime_percent)]
        self.remaining_lives = [10]
        self.last_ate = 0
        observation = self._get_obs()
        info = {}

        return observation, info

    def step(self, action):
        """
        Rewards need to tie in time, lives, whether the level is won or lost and whether
        the number eaten is good or bad
        """
        self.last_ate += 1
        self.was_prime = False
        if action == 0 and self.player_pos[1] < 4:
            self.player_pos[1] += 1
        elif action == 1 and self.player_pos[1] > 0:
            self.player_pos[1] -= 1
        elif action == 2:
            self.eat()
            self.last_ate = 0
        elif action == 3 and self.player_pos[0] < 4:
            self.player_pos[0] += 1
        elif action == 4 and self.player_pos[0] > 0:
            self.player_pos[0] -= 1

        # print(action[0], self.current_number, self.board, self.player_pos)
        self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]

        if not self.remaining_number_of_primes[0] and self.max != 100:
            self.max += 5

        max_n = self.max
        if self.max > max_n:
            max_n = self.max

        self.render()

        if self.remaining_lives[0] == 0:
            self.max = 5

        total_reward = self.calculate_rewards(action)
        terminated = not self.remaining_lives[0] or not self.remaining_number_of_primes[0]
        obs = self._get_obs()
        info = {}

        # PC modification
        if terminated:
            self.reset()

        return obs, total_reward, terminated, False, info

    def gen_board(self):
        prime_numbers = list(sympy.primerange(1, self.prime_range + 1))

        possible_non_primes = np.arange(1, self.max)
        non_prime_numbers = possible_non_primes[~np.isin(possible_non_primes, prime_numbers)]

        number_of_primes = int(self.prime_percent * self.size * self.size)
        prime_cells = np.random.choice(prime_numbers, number_of_primes, replace=True)

        number_of_non_primes = (self.size * self.size) - number_of_primes
        non_prime_cells = np.random.choice(non_prime_numbers, number_of_non_primes, replace=True)

        board = np.append(prime_cells, non_prime_cells)
        np.random.shuffle(board)
        board = np.reshape(board, (self.size, self.size))

        return board, prime_cells

    def eat(self):
        if sympy.isprime(self.current_number):
            self.was_prime = True
            if self.remaining_number_of_primes[0] > 0:
                self.remaining_number_of_primes[0] -= 1
        else:
            if self.remaining_lives[0] > 0:
                self.remaining_lives[0] -= 1

        self.board[self.player_pos[0]][self.player_pos[1]] = 0

    def calculate_rewards(self, action):
        # V1
        # total_reward = + 0.2 * self.remaining_lives[0] - 0.1 * self.time_spent
        # if action == 2:
        #     total_reward += - 0.8 * (not self.was_prime) + - 0.5 * self.was_prime
        # else:
        #     total_reward += - 1 * (not self.remaining_lives[0]) + 1 * (not self.remaining_number_of_primes[0])

        # V2
        # total_reward = -20
        # if self.remaining_lives[0] == 0:
        #     total_reward -= 30
        #
        # if self.remaining_number_of_primes[0] == 0:
        #     total_reward += 50
        #
        # if self.was_prime and action == 2:
        #     total_reward += 25
        #
        # if self.was_prime and action != 2:
        #     total_reward -= 20
        #
        # if not self.was_prime and action == 2:
        #     total_reward -= 15

        # V3
        # total_reward = 0
        # if action != 2:
        #     total_reward -= self.last_ate
        # else:
        #     if self.was_prime:
        #         total_reward += 15 + self.remaining_lives[0]
        #         if self.remaining_number_of_primes[0] == 0:
        #             total_reward += 25 + (60 - self.time_spent[0])
        #     if not self.was_prime:
        #         total_reward -= self.last_ate * 1.5
        #         if self.remaining_lives[0] == 0 or self.time_spent == 60:
        #             total_reward -= self.last_ate * 30

        # V4
        # total_reward = 0
        # if self.was_prime:
        #     total_reward += 15 + self.remaining_lives[0]
        #
        # if self.remaining_number_of_primes[0] == 0:
        #     total_reward += 50
        #
        # if self.remaining_lives[0] == 0:
        #     total_reward -= 10

        # V5
        total_reward = 5 * (int(self.prime_percent * self.size * self.size) - self.remaining_number_of_primes[0]) \
                       + 5 * self.remaining_lives[0] - 10 * (not self.was_prime)

        # if self.remaining_number_of_primes[0] == 0:
        #     total_reward += 50
        #
        # if not self.was_prime or self.current_number == 0:
        #     total_reward -= 50
        #
        # if self.remaining_lives[0] == 0:
        #     total_reward -= 20

        return total_reward

    def render(self):
        if not self.render_mode:
            print(f"Level: Terminated, Remaining Lives: {self.remaining_lives}, "
                  f"Remaining Primes: {self.remaining_number_of_primes}, Current Max Number:{self.max} "
                  f"Current Number: {self.current_number}"
                  f"Player Position: {self.player_pos}")
        else:
            # print(f"Remaining Lives: {self.remaining_lives}, Remaining Primes: {self.remaining_number_of_primes}, "
            #       f"Time Spent: {self.time_spent}")
            # Initialize Pygame
            pygame.init()
            clock = pygame.time.Clock()

            # Constants
            SCREEN_WIDTH = 400
            SCREEN_HEIGHT = 400
            CELL_SIZE = SCREEN_WIDTH // self.size
            AGENT_COLOR = (255, 0, 0)
            BOARD_COLOR = (200, 200, 200)
            FONT_SIZE = 30

            screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
            pygame.display.set_caption("Number Muncher")

            for i in range(self.size):
                for j in range(self.size):
                    pygame.draw.rect(screen, BOARD_COLOR, (j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE), 0)
                    font = pygame.font.Font(None, FONT_SIZE)
                    number_text = font.render(str(self.board[i, j]), True, (0, 0, 0))
                    screen.blit(number_text, (j * CELL_SIZE + CELL_SIZE // 3, i * CELL_SIZE + CELL_SIZE // 3))

            # Draw the agent
            agent_rect = pygame.Rect(self.player_pos[1] * CELL_SIZE, self.player_pos[0] * CELL_SIZE, CELL_SIZE,
                                     CELL_SIZE)
            pygame.draw.rect(screen, AGENT_COLOR, agent_rect)

            pygame.display.flip()
            clock.tick(4)


Pl = Player()
Pl.reset()
Pl.step(2)
print(Pl.board)
